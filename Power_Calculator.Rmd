---
title: "Power_Calculator"
author: "Nasimeh & Anastasia"
date: "7/5/2022"
output: html_document
---

# Power calculator

# The purpose:
#We use simulated methylation data to run different statistical analysis to test the power for different combination of parameters. Currently user can choose two parameters that can vary at the same time (specified for the SimMethyl part of the pipeline).

#Input
#1) Test statistics (Limma, t-test, KS-test)
#2) Beta-value transformation
#3) Method for p-value adjustment
#3) p-cut (FDR critical value)
#4) Number of simulated data
#5) x- and y-parameters  (the same parameters that has been specified as varied in the SimMthyl)
#6) p-value threshold 

#Results
#Power statistics for each 3 test statistics and line-/heat plots. 

```{r setup, include=FALSE}
library(limma)
library(caret) # for construction of confusion matrix, confusionMatrix()
library(ggplot2)
```

```{r setup, include=FALSE}
#Importing the zip files generated by SimMethyl (uses current working directory, so zip files from SimMethyl should be located inside the current working directory)

unzip_file = function(zip_order){

temp = paste0(getwd(),"/SimMethyl_run_",zip_order,".zip")
list_of_txts<-unzip(temp,exdir = getwd())
file1 = read.table(list_of_txts[1])
file2 = read.table(list_of_txts[2])
file3 = read.table(list_of_txts[3], header = TRUE)
list_workflow = list(file1, file2, file3)
return(list_workflow)
}
```

```{r setup, include=FALSE}
#Import all zip-files, that is total number of simulated data sets.
Get_all_zip = function(n_zip){
all_runs_output = list()
for (i in 1:n_zip){
  run = unzip_file(i)
  all_runs_output[[i]] = run
}
return(all_runs_output)
}
```


```{r setup, include=FALSE}
#Each zip-file includes 3 different documents with information about truly modified CpG sides, parameters used for testing and the simulated data. Extracts a specific file from any zip file.
# OBS! works only for multiple zip files (more than 1 zip/simulation), in the case of single zip returns a matrix not a data frame
extract_data_from_zip = function(all_runs_zip_num, zip_order_num, file_name){
file_name_to_extract = ifelse(file_name=="Simulated_data",1,ifelse(file_name=="truly_different_sites_indices",2,ifelse(file_name=="User_Parameters",3,warning("WRONG_file_name"))))
all_zip = Get_all_zip(all_runs_zip_num)
extracted_data = all_zip [[ zip_order_num]][[file_name_to_extract]]
return(extracted_data)
}


```


```{r setup, include=FALSE}
#Obtaining information on user-specified number of samples per group based on the defined healthy proportion (control-case balance) in the SimMethyl. 
get_num_samp_per_group = function(all_zips, zip_file_order, simulated_data_frame){
user_parameters = extract_data_from_zip(all_zips, zip_file_order, "User_Parameters")
healthy_proportion = user_parameters$Value[user_parameters$Parameter == "Healthy proportion"]
n_Group1 = ncol(simulated_data_frame)*healthy_proportion
n_Group2 = ncol(simulated_data_frame)*(1-healthy_proportion)
num_groups = c(n_Group1,n_Group2)
return(num_groups)
}

```


```{r setup, include=FALSE}
#Traditional t-test - parametric test

local_t_test = function(simulated_data_frame,n_group1){

store_all_p_val= c()
for(i in 1:nrow(simulated_data_frame)){
t_test_output = t.test(simulated_data_frame[i,1:n_group1],simulated_data_frame[i,(n_group1+1):ncol(simulated_data_frame)])
p_value = t_test_output$p.value
store_all_p_val[i] = p_value
}
method = t_test_output$method
all_p_values = as.data.frame(store_all_p_val)
names(all_p_values) = method
return(all_p_values)
}  

```


```{r setup, include=FALSE}
#Kolmogorov-Smirnov Tests - non-parametric

local_Ks_test = function(simulated_data_frame,n_group1){

store_all_p_val= c()
for(i in 1:nrow(simulated_data_frame)){
  gr1 = as.numeric(simulated_data_frame[i,1:n_group1])
  gr2 = as.numeric(simulated_data_frame[i,(n_group1+1):ncol(simulated_data_frame)])
KS_test_output = ks.test(gr1,gr2,alternative = "two.sided", exact = TRUE)
p_value = KS_test_output$p.value
store_all_p_val[i] = p_value
}
method = KS_test_output$method
all_p_values = as.data.frame(store_all_p_val)
names(all_p_values) = method
return(all_p_values)
}

```

```{r setup, include=FALSE}
#Limma - parametric test

local_limma_test = function(simulated_data_frame,n_group1,n_group2){

Group1 = c(rep(1,n_group1),rep(0,n_group2))
Group2 = c(rep(0,n_group1),rep(1,n_group2))
design_matrix = as.data.frame(cbind(Group1,Group2)) 
contrast_matrix = makeContrasts(Diff = Group2 - Group1, levels = design_matrix)

fit1 <- lmFit(simulated_data_frame, design_matrix)
fit2 <- contrasts.fit(fit1, contrast_matrix)
fit3 <- eBayes(fit2)
limma_output = as.data.frame(fit3)
limma_Pvalues = as.data.frame(limma_output$p.value)
names(limma_Pvalues) = "limma"
return(limma_Pvalues)
}

```

```{r setup, include=FALSE}
#Transformation of beta-values to M-values
logit_transformation = function (beta_matrix){
 beta_matrix <- ifelse(as.matrix(beta_matrix)>=1, 0.99, as.matrix(beta_matrix))
 beta_matrix <- ifelse(as.matrix(beta_matrix)<=0, 0.00000000000000001, as.matrix(beta_matrix))
  beta_transform = log2(beta_matrix/(1-beta_matrix))
  return(beta_transform)
}

```

```{r setup, include=FALSE}
#  Running all the tests to compare the two groups for every CpG site based on either transformed or original values. The output is p-values for every CpG site and for every test. 
run_all_test = function(all_zips, zip_file_order,beta_or_M_string){
simulated_data_frame = extract_data_from_zip(all_zips,zip_file_order,"Simulated_data")
  
  if(beta_or_M_string == "M"){
    simulated_data_frame = as.data.frame(logit_transformation(simulated_data_frame))
  } 
  else if(beta_or_M_string == "beta"){
    simulated_data_frame = simulated_data_frame
  } 
  else{
    warning("invalid input for beta_or_M_string, use M or beta")
  }

n_samples_per_gr = get_num_samp_per_group(all_zips,zip_file_order,simulated_data_frame)
n_group1 = n_samples_per_gr[1]
n_group2 = n_samples_per_gr[2]

t_test_ouput = local_t_test(simulated_data_frame, n_group1)
ks_output = local_Ks_test(simulated_data_frame,n_group1)
local_limma_output = local_limma_test(simulated_data_frame,n_group1,n_group2)
all_test_output = cbind(t_test_ouput,ks_output,local_limma_output)
return(all_test_output)
}

```


```{r setup, include=FALSE}
#Adjust p-values based on the selected method. The input is the p-values for every CpG obtained from a specific test.

getadjustPval = function(p_val_vector, method){
  p_val_adjusted = p.adjust(p_val_vector, method = method)
  return(p_val_adjusted)
}
```


```{r setup, include=FALSE}
# Adjust p-values for all tests.
multitest_p_adjust = function(all_test_df, p_adjust_method_string){
  store_p_adjust = data.frame(matrix(data=NA,nrow = nrow(all_test_df), ncol = ncol(all_test_df)))
  names(store_p_adjust) = names(all_test_df)
  for (p_val_test in 1:ncol(all_test_df)){
    store_p_adjust[,p_val_test] = getadjustPval(all_test_df[,p_val_test],p_adjust_method_string)
  }
return(store_p_adjust)
}

```


```{r setup, include=FALSE}
# prior to confusion matrix construction, CpGs should be labeled based on two distinction characteristics: whether they are truly modified, and if their adjusted p-valued is less than 0.05.

#The input is the vector with observed values within the simulated data. The output is a boolean which represents if the observation is significantly different between the two groups (0) and not significant (1)

create_predicted_vector = function(p_val_vector, p_cut){
  signif_threshold = as.numeric(p_cut)
  boolean_signif_p_val= ifelse (p_val_vector<signif_threshold,0,1)
  boolean_signif_p_val = as.factor(boolean_signif_p_val)
  return(boolean_signif_p_val)
}



```


```{r setup, include=FALSE}
#Extract expected values, that is indices of the ground truth (truly modified CpGs). The output is a boolean which represents the truly differentiated methylation (0) and not-modified CpG sites (1). 

create_expected_val_vector = function(p_val_df,all_runs_zip_num,zip_order_num){
  indices_truly_different = extract_data_from_zip(all_runs_zip_num,zip_order_num,"truly_different_sites_indices")
  indices_truly_different = indices_truly_different$V1
  
  indices_p_val_vector = seq(1, nrow(p_val_df), by=1)
  boolean_truly_modif = as.integer(!indices_p_val_vector %in% indices_truly_different)
  boolean_truly_modif = factor(boolean_truly_modif)
  return(boolean_truly_modif)
} 
```


```{r setup, include=FALSE}
#Created a confusion matrix using observed and predicted values for every CpG. Create confusion matrix for every test. 
create_confusion_matrix = function(all_test_df, all_runs_zip_num, zip_order_num,p_cut){
  expected = create_expected_val_vector(all_test_df, all_runs_zip_num, zip_order_num)
  confusion_matrix = list()
  for (i in 1:ncol(all_test_df)){
  predicted = create_predicted_vector(all_test_df[,i], p_cut)
  confusion_matrix[[i]] = confusionMatrix(data= predicted, reference=expected) 
  }
  names(confusion_matrix) = names(all_test_df)
  return(confusion_matrix)
}

```


```{r setup, inc=lude=FALSE}
# Calculating marginal power based on categories within confusion matrix for every test. 

calc_empirical_marg_power = function(all_confusionMatrix_list){
  df_all_test = as.data.frame(matrix(data=NA, nrow=3,ncol=2))
  names(df_all_test) = c("Power", "test")
  df_all_test$test = c("t_test","KS_test", "limma")
  
  for (i in 1:length(all_confusionMatrix_list)){
  confusion_matrix = all_confusionMatrix_list[[i]]
  true_positive = confusion_matrix$table[1]
  false_positive = confusion_matrix$table[2]
  false_negative = confusion_matrix$table[3]
  true_negative = confusion_matrix$table[4]
  power_calc_val = true_positive/(true_positive + false_negative)
  df_all_test$Power[i] = power_calc_val

  }
  return(df_all_test)
}
```


```{r setup, include=FALSE}
#Calculate marginal power for every experimental setup 
power_calc_multiple_runs = function(all_zips, p_adjust_method_string, beta_or_M_string, p_cut){
  df_all_test = as.data.frame(matrix(data=NA, nrow=3,ncol=3))
  names(df_all_test) = c("Power", "test", "ID")
  for (i in 1:all_zips){
    all_test = run_all_test(all_zips, i,beta_or_M_string) 
    p_adjust_all_test = multitest_p_adjust(all_test,p_adjust_method_string)
    confusion_matrix = create_confusion_matrix(all_test, all_zips, i, p_cut)
    calc_power_value = calc_empirical_marg_power(confusion_matrix)
    calc_power_value$ID = rep(i,3) #adding new column with IDs (zip ID)
    df_all_test = rbind(df_all_test,  calc_power_value)
  }
  df_all_test=na.omit(df_all_test)
  
  return(df_all_test)
}

```


```{r setup, include=FALSE}
#Obtain values for all user-defined parameters specified in SimMethyl. 
get_all_parameters = function(all_zips){

temp_df = as.data.frame(matrix(data=NA, nrow=1,ncol=5))
names(temp_df) = c("n_samples", "n_CpGs", "healthy_proportion", "effect_size", "n_modified_CpGs")
ID = c()
for (i in 1:all_zips){
  ID[i] = i
    user_parameters = extract_data_from_zip(all_zips, i, "User_Parameters")
    user_parameters = t(user_parameters)
    user_parameters = user_parameters[-1,]
    temp_df = rbind(temp_df,  user_parameters)
}
  temp_df=na.omit(temp_df)
  temp_df$ID = ID
  temp_df$n_samples = as.numeric(temp_df$n_samples)
  temp_df$n_CpGs = as.numeric(temp_df$n_CpGs)
  temp_df$healthy_proportion = as.numeric(temp_df$healthy_proportion)
  temp_df$effect_size = as.numeric(temp_df$effect_size)
  temp_df$n_modified_CpGs = as.numeric(temp_df$n_modified_CpGs)
  return(temp_df)
}

```


```{r setup, include=FALSE}
#Combine user parameters with the output of the power calculation step using IDs (an ID = a zip)
merge_data = function(all_zips, p_adjust_method_string,beta_or_M_string, p_cut){
power_calc_val = power_calc_multiple_runs(all_zips,p_adjust_method_string,beta_or_M_string,p_cut)
parameters = get_all_parameters(all_zips)
output_df = merge(power_calc_val, parameters, by="ID")
print(head(output_df))
return(output_df)
}

```


```{r setup, include=FALSE}
# Plot data as line for eery test
plot_line = function(data_df,y_parameter_string,varied_parameter_string, p_adjust_method_string,beta_or_M_string){ 
    selected_parameters_df = data_df[,names(data_df) %in% c(y_parameter_string,varied_parameter_string,"test","Power")]
print(selected_parameters_df)
y_parameter=y_parameter_string
varied_parameter = varied_parameter_string

column_names = names(selected_parameters_df)
column_names = gsub(y_parameter,"y_parameter",column_names)
column_names = gsub(varied_parameter,"varied_parameter",column_names)
names(selected_parameters_df) = column_names


for (i in 1:length(unique(selected_parameters_df$varied_parameter))){
print(i)
selected_parameters = selected_parameters_df[selected_parameters_df$varied_parameter==unique(selected_parameters_df$varied_parameter)[i],]
fig = ggplot(selected_parameters, aes(x=Power , y=y_parameter, color = test)) +
    geom_line()+
    geom_point(aes(shape=test))+ 
    ylim(min(selected_parameters$y_parameter),max(selected_parameters$y_parameter))+ 
    xlim(0,1)+ 
      labs(x="Power",y=y_parameter) +
    theme_minimal() 
    #theme(plot.margin = unit(c(0,1,0,0),"lines")) + 
    #coord_cartesian(clip = "off") +
  
    #annotate(geom = "text", label=paste(varied_parameter,"\n",unique(selected_parameters$varied_parameter[i]))) 
varied_param_i = unique(selected_parameters$varied_parameter[i])
png(paste0("LinePlot_",y_parameter,"_vs_Power_",varied_parameter,"_step_",varied_param_i,"_",p_adjust_method_string,"_",beta_or_M_string,".png"))
print(fig)
dev.off()
}
}

```

```{r setup, include=FALSE}
# plot heatmap with power as color when varying two parameters.
heat_map = function(data_df,x_parameter_string,y_parameter_string,test_string,p_adjust_method_string,beta_or_M_string){
selected_parameters_df = data_df[,names(data_df) %in% c("test","Power",x_parameter_string,y_parameter_string)]
y_parameter = y_parameter_string
x_parameter = x_parameter_string

column_names = names(selected_parameters_df)
column_names = gsub(y_parameter,"y_parameter",column_names)
column_names = gsub(x_parameter,"x_parameter",column_names)
names(selected_parameters_df) = column_names
  
selected_parameters_df$Power = as.numeric(format(selected_parameters_df$Power, digits = 2))
selected_parameters_df = selected_parameters_df[selected_parameters_df$test == test_string,]
fig = ggplot(selected_parameters_df, aes(x = x_parameter, y = y_parameter, fill = Power)) +
  geom_tile(color = "white", lwd=1) +
  labs(x=x_parameter,y=y_parameter) +
  geom_text(aes(label = Power), color = "white", size = 5) 

#save_data_name = paste0("/PowerCalc_",y_parameter_string,"_",x_parameter_string,"/")
png(paste0("HeatMap_",y_parameter,"_vs_",x_parameter,"_colorfill_Power",test_string,"_",p_adjust_method_string,"_",beta_or_M_string,".png"))
print(fig)
dev.off()
}

```


```{r setup, include=FALSE}
#Aggregate function that calculates marginal power for all the tests across samples based on user-defined inputs. As an output it generates line plots and heat maps that shows the relationship between power and two varying parameters and three constant parameters. 
PowerCalc = function(num_zips,p_adjust_method_string,beta_or_M_string,y_parameter_string,x_parameter_string,color_string,test_vector_string,p_cut){
  get_work_dir = getwd()
  all_test_all_zips = merge_data(num_zips,p_adjust_method_string,beta_or_M_string,p_cut)
  #save_data_name = paste0("/PowerCalc_",y_parameter_string,"_",x_parameter_string,"/")
  dir.create(paste0(getwd(),"/PowerCalc_",y_parameter_string,"_",x_parameter_string))
  setwd(paste0(getwd(),"/PowerCalc_",y_parameter_string,"_",x_parameter_string))
  write.csv(all_test_all_zips,paste0("PowerCalc_tests_results_",beta_or_M_string,"_",p_adjust_method_string, sep=" ",".csv"), col.names = TRUE, row.names = TRUE)
  
  plot_line(all_test_all_zips,y_parameter_string, x_parameter_string,p_adjust_method_string,beta_or_M_string)
  
  for (test in 1:length(test_vector_string)){
    heat_map(all_test_all_zips,x_parameter_string, y_parameter_string, test_vector_string[test],p_adjust_method_string,beta_or_M_string)
    print(test)
  }
  setwd(get_work_dir)
}
```

```{r setup, include=FALSE}
start.time <- Sys.time()
print(paste0("Start Time ", start.time))

num_zips = 35 # number of simulated data zip files
p_adjust_method_string = "BH" #"none"/"BH"/"bonferroni"/"fdr"
beta_or_M_string = "M" #"beta"/"M"
y_parameter_string = "n_samples" # "n_samples"/"n_CpGs"/"healthy_proportion"/"effect_size"/"n_modified_CpGs"
x_parameter_string = "effect_size" # "n_samples"/"n_CpGs"/"healthy_proportion"/"effect_size"/"n_modified_CpGs"
color_string = "Power"
test_vector_string = c("t_test","limma", "KS_test")
p_cut = 0.05 #0.01, 0.1

PowerCalc(num_zips,p_adjust_method_string,beta_or_M_string,y_parameter_string,x_parameter_string,color_string,test_vector_string,p_cut)

end.time <- Sys.time()
print(paste0("End Time ", end.time))
time.taken <- end.time - start.time
print(paste0("Time Taken ", time.taken))
```

