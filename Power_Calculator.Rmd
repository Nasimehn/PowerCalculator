---
title: "Power_Calculator"
author: "Nasimeh & Anastasia"
date: "7/5/2022"
output: html_document
---

```{r setup, include=FALSE}
library(limma)
library(caret)
library(ggplot2)
#library(reshape)
```

```{r setup, include=FALSE}
unzip_file = function(zip_order){

#temp = list.files(path=getwd(), pattern = paste0("SimMethyl_run_",item))
temp = paste0(getwd(),"/SimMethyl_run_",zip_order,".zip")
list_of_txts<-unzip(temp,exdir = getwd()) #,list=TRUE
file1 = read.table(list_of_txts[1])
file2 = read.table(list_of_txts[2])
file3 = read.table(list_of_txts[3], header = TRUE)
list_workflow = list(file1, file2, file3)
return(list_workflow)
}
```

```{r setup, include=FALSE}
Get_all_zip = function(n_zip){
all_runs_output = list()
for (i in 1:n_zip){
  run = unzip_file(i)
  all_runs_output[[i]] = run
}
return(all_runs_output)
}
```


```{r setup, include=FALSE}
extract_data_from_zip = function(all_runs_zip_num, zip_order_num, file_name){
file_name_to_extract = ifelse(file_name=="Simulated_data",1,ifelse(file_name=="truly_different_sites_indices",2,ifelse(file_name=="User_Parameters",3,warning("WRONG_file_name"))))
all_zip = Get_all_zip(all_runs_zip_num)
extracted_data = all_zip [[ zip_order_num]][[file_name_to_extract]]
return(extracted_data)
}

#works only for a multiple zip files, in the case of single zip returns a matrix not a data frame
```

```{r setup, include=FALSE}

Simulated_data <- extract_data_from_zip(all_zips,2,"Simulated_data")

```

```{r setup, include=FALSE}
get_num_samp_per_group = function(all_zips, zip_file_order, simulated_data_frame){
user_parameters = extract_data_from_zip(all_zips, zip_file_order, "User_Parameters")
healthy_proportion = user_parameters$Value[user_parameters$Parameter == "Healthy proportion"]
n_Group1 = ncol(simulated_data_frame)*healthy_proportion
n_Group2 = ncol(simulated_data_frame)*(1-healthy_proportion)
num_groups = c(n_Group1,n_Group2)
return(num_groups)
}

```


```{r setup, include=FALSE}

local_t_test = function(all_zips,zip_file_order){
simulated_data_frame = extract_data_from_zip(all_zips,zip_file_order,"Simulated_data")
simulated_data_frame = logit_transformation(simulated_data_frame)
n_samples_per_gr = get_num_samp_per_group(all_zips,zip_file_order,simulated_data_frame)
n_group1 = n_samples_per_gr[1]

store_all_p_val= c()
for(i in 1:nrow(simulated_data_frame)){
t_test_output = t.test(simulated_data_frame[i,1:n_group1],simulated_data_frame[i,(n_group1+1):ncol(simulated_data_frame)])
p_value = t_test_output$p.value
store_all_p_val[i] = p_value
}
method = t_test_output$method
all_p_values = as.data.frame(store_all_p_val)
names(all_p_values) = method
return(all_p_values)
}  

```


```{r setup, include=FALSE}
# #Kolmogorov-Smirnov Tests - non-parametric
#remember to use the input as M-values
# the test is different from t-test as it compares distribution functions of the two groups as opposed to 
# only mean values are compared in t-test.
local_Ks_test = function(all_zips,zip_file_order){
simulated_data_frame = extract_data_from_zip(all_zips,zip_file_order,"Simulated_data")
simulated_data_frame = logit_transformation(simulated_data_frame)
n_samples_per_gr = get_num_samp_per_group(all_zips,zip_file_order,simulated_data_frame)
n_group1 = n_samples_per_gr[1]

store_all_p_val= c()
for(i in 1:nrow(simulated_data_frame)){
  gr1 = as.numeric(simulated_data_frame[i,1:n_group1])
  gr2 = as.numeric(simulated_data_frame[i,(n_group1+1):ncol(simulated_data_frame)])
KS_test_output = ks.test(gr1,gr2,alternative = "two.sided", exact = TRUE)
p_value = KS_test_output$p.value
store_all_p_val[i] = p_value
}
method = KS_test_output$method
all_p_values = as.data.frame(store_all_p_val)
names(all_p_values) = method
return(all_p_values)
}

```

```{r setup, include=FALSE}
#Limma #bayesian based 

local_limma_test = function(all_zips,zip_file_order){
# model.matrix(~ simulated_data$Group2) - by manually
simulated_data_frame = extract_data_from_zip(all_zips,zip_file_order,"Simulated_data")
simulated_data_frame = logit_transformation(simulated_data_frame)
n_samples_per_gr = get_num_samp_per_group(all_zips,zip_file_order,simulated_data_frame)
n_group1 = n_samples_per_gr[1]
n_group2 = n_samples_per_gr[2]
Group1 = c(rep(1,n_group1),rep(0,n_group2))
Group2 = c(rep(0,n_group1),rep(1,n_group2))
design_matrix = as.data.frame(cbind(Group1,Group2)) 
contrast_matrix = makeContrasts(Diff = Group2 - Group1, levels = design_matrix)

fit1 <- lmFit(simulated_data_frame, design_matrix)
fit2 <- contrasts.fit(fit1, contrast_matrix)
fit3 <- eBayes(fit2)
limma_output = as.data.frame(fit3)
limma_Pvalues = as.data.frame(limma_output$p.value)
names(limma_Pvalues) = "limma"
return(limma_Pvalues)
}

```


```{r setup, include=FALSE}
#test-statistics for all CpGs for each test
run_all_test = function(all_zips, zip_file_order){
t_test_ouput = local_t_test(all_zips, zip_file_order)
ks_output = local_Ks_test(all_zips, zip_file_order)
local_limma_output = local_limma_test(all_zips, zip_file_order)
all_test_output = cbind(t_test_ouput,ks_output,local_limma_output)
all_test_p_adjusted = apply(all_test_output,2, getadjustPval)
return(all_test_p_adjusted)
}

```


```{r setup, include=FALSE}
logit_transformation = function (Beta_matrix){
 Beta_matrix <- ifelse(as.matrix(Beta_matrix)>=1, 0.99, as.matrix(Beta_matrix))
 Beta_matrix <- ifelse(as.matrix(Beta_matrix)<=0, 0.00000000000000001, as.matrix(Beta_matrix))
  beta_transform = log2(Beta_matrix/(1-Beta_matrix))
  return(beta_transform)
}

```


```{r setup, include=FALSE}
#When you adjust the p-values are more insignificant (penalty) 

getadjustPval = function(p_val_vector){
  p_val_adjusted = p.adjust(p_val_vector, method = "BH")
  return(p_val_adjusted)
}
```


```{r setup, include=FALSE}
create_predicted_vector = function(p_val_vector){
  signif_threshold = 0.05
  boolian_signif_p_val= ifelse (p_val_vector<signif_threshold,0,1)
  boolian_signif_p_val = as.factor(boolian_signif_p_val)
#levels(boolian_signif_p_val) = c(1,0)
  return(boolian_signif_p_val)
}
```


```{r setup, include=FALSE}
create_expected_val_vector = function(p_val_df,all_runs_zip_num,zip_order_num){
  indices_truly_different = extract_data_from_zip(all_runs_zip_num,zip_order_num,"truly_different_sites_indices")
  indices_truly_different = indices_truly_different$V1
  
  indices_p_val_vector = seq(1, nrow(p_val_df), by=1)
  boolian_truly_modif = as.integer(!indices_p_val_vector %in% indices_truly_different)
  boolian_truly_modif = factor(boolian_truly_modif)
  return(boolian_truly_modif)
} 
#create_expected_val_vector(all_test_output$`Welch Two Sample t-test` ,2,2)
```

```{r setup, include=FALSE}
create_confusion_matrix = function(all_test_df, all_runs_zip_num, zip_order_num){
  expected = create_expected_val_vector(all_test_df, all_runs_zip_num, zip_order_num)
  confusion_matrix = list()
  for (i in 1:ncol(all_test_df)){
  predicted = create_predicted_vector(all_test_df[,i])
  confusion_matrix[[i]] = confusionMatrix(data= predicted, reference=expected) 
  }
  names(confusion_matrix) = names(all_test_df)
  return(confusion_matrix)
}

```


```{r setup, inc=lude=FALSE}
calc_empirical_marg_power = function(all_confusionMatrix_list){
  df_all_test = as.data.frame(matrix(data=NA, nrow=3,ncol=2))
  names(df_all_test) = c("Power", "test")
  df_all_test$test = c("t_test","KS_test", "limma")
  
  for (i in 1:length(all_confusionMatrix_list)){
  confusion_matrix = all_confusionMatrix_list[[i]]
  extract_confTable= table(confusion_matrix$table)
  false_negative = as.numeric(names(extract_confTable)[1])
  true_positive = as.numeric(names(extract_confTable)[2])
  false_positive = as.numeric(names(extract_confTable)[3])
  true_negtaive = as.numeric(names(extract_confTable)[4])
  power_calc_val = true_positive/(true_positive + false_negative)
  df_all_test$Power[i] = power_calc_val

  }
  return(df_all_test)
}
```


```{r setup, include=FALSE}
power_calc_multiple_runs = function(all_zips){
  df_all_test = as.data.frame(matrix(data=NA, nrow=3,ncol=3))
  names(df_all_test) = c("Power", "test", "ID")
  for (i in 1:all_zips){
    All_test = run_all_test(all_zips, i)
    confusion_matrix = create_confusion_matrix(All_test, all_zips, i)
    calc_power_value = calc_empirical_marg_power(confusion_matrix)
    calc_power_value$ID = rep(i,3) #adding new column with IDs (zip ID)
    df_all_test = rbind(df_all_test,  calc_power_value)
  }
  df_all_test=na.omit(df_all_test)
  return(df_all_test)
}

```


```{r setup, include=FALSE}
get_all_parameters = function(all_zips){

temp_df = as.data.frame(matrix(data=NA, nrow=1,ncol=5))
names(temp_df) = c("n_samples", "n_CpGs", "healthy_proportion", "effect_size", "n_modified_CpGs")
ID = c()
for (i in 1:all_zips){
  ID[i] = i
    user_parameters = extract_data_from_zip(all_zips, i, "User_Parameters")
    user_parameters = t(user_parameters)
    user_parameters = user_parameters[-1,]
    temp_df = rbind(temp_df,  user_parameters)
}
  temp_df=na.omit(temp_df)
  temp_df$ID = ID
  temp_df$n_samples = as.numeric(temp_df$n_samples)
  temp_df$n_CpGs = as.numeric(temp_df$n_CpGs)
  temp_df$healthy_proportion = as.numeric(temp_df$healthy_proportion)
  temp_df$effect_size = as.numeric(temp_df$effect_size)
  temp_df$n_modified_CpGs = as.numeric(temp_df$n_modified_CpGs)
  return(temp_df)
}

```


```{r setup, include=FALSE}
merge_data = function(all_zips){
power_calc_val = power_calc_multiple_runs(all_zips)
parameters = get_all_parameters(all_zips)
output_df = merge(power_calc_val, parameters, by="ID")
return(output_df)
}

```


```{r setup, include=FALSE}
plot_line = function(data_df,y_parameter_string,varied_parameter_string){ 
    selected_parameters_df = data_df[,names(data_df) %in% c(y_parameter_string,varied_parameter_string,"test","Power")]
print(selected_parameters_df)
y_parameter=y_parameter_string
varied_parameter = varied_parameter_string

column_names = names(selected_parameters_df)
column_names = gsub(y_parameter,"y_parameter",column_names)
column_names = gsub(varied_parameter,"varied_parameter",column_names)
names(selected_parameters_df) = column_names

for (i in 1:length(unique(selected_parameters_df$varied_parameter))){
print(i)
selected_parameters = selected_parameters_df[selected_parameters_df$varied_parameter==unique(selected_parameters_df$varied_parameter)[i],]
fig = ggplot(selected_parameters, aes(x=Power , y=y_parameter, color = test)) +
    geom_line()+
    geom_point(aes(shape=test))+ 
    ylim(min(selected_parameters$y_parameter),max(selected_parameters$y_parameter))+ 
    xlim(0,1)+ 
      labs(x="Power",y=y_parameter) +
    theme_minimal() 
    #theme(plot.margin = unit(c(0,1,0,0),"lines")) + 
    #coord_cartesian(clip = "off") +
  
    #annotate(geom = "text", label=paste(varied_parameter,"\n",unique(selected_parameters$varied_parameter[i]))) 
varied_param_i = unique(selected_parameters$varied_parameter[i])
png(paste0("LinePlot_",y_parameter,"_vs_Power_",varied_parameter,"_step_",varied_param_i,".png"))
print(fig)
dev.off()
}
}

```

```{r setup, include=FALSE}
heat_map = function(data_df,x_parameter_string,y_parameter_string,color_string,test_string){
selected_parameters_df = data_df[,names(data_df) %in% c("test",color_string,x_parameter_string,y_parameter_string)]
y_parameter = y_parameter_string
x_parameter = x_parameter_string

column_names = names(selected_parameters_df)
column_names = gsub(y_parameter,"y_parameter",column_names)
column_names = gsub(x_parameter,"x_parameter",column_names)
names(selected_parameters_df) = column_names
  
selected_parameters_df$Power = as.numeric(format(selected_parameters_df$Power, digits = 2))
selected_parameters_df = selected_parameters_df[selected_parameters_df$test == test_string,]
fig = ggplot(selected_parameters_df, aes(x = x_parameter, y = y_parameter, fill = Power)) +
  geom_tile(color = "white", lwd=1) +
  labs(x=x_parameter,y=y_parameter) +
  geom_text(aes(label = Power), color = "white", size = 5) 

png(paste0("HeatMap_",y_parameter,"_vs_",x_parameter,"_colorfill_power",test_string,".png"))
print(fig)
dev.off()
}

```


```{r setup, include=FALSE}
PowerCalc = function(num_zips,y_parameter_string,x_parameter_string,color_string,test_vector_string){
  all_test_all_zips = merge_data(num_zips)
  write.table(all_test_all_zips, "PowerCalc_tests_results.txt", col.names = TRUE)
  Mval_all_test = logit_transformation()
  plot_line(Mval_all_test,y_parameter_string, x_parameter_string)
  plot_line(all_test_all_zips,y_parameter_string, x_parameter_string)
  for (test in 1:length(test_vector_string)){
    heat_map(all_test_all_zips,x_parameter_string, y_parameter_string, color_string, test_vector_string[test])
  }
}
```